# MongoDB

## Introduction

- a general purpose document database, structure data into documents similar to JSON objects
- not using the relational database schemas of tables, columns or rows
- offers a developer-friendly way to access the data
- corresponds objects in code
- document model is easier to plan how application data will correspond to data in the databases
- model data of any shape or structure
- use one format for every language

```javascript
    // example of a document
    {
        "id" : 1,
        "name" : {
            "first" : "Ada",
            "last" : "Lovelace"
        },
        "title" : "The First Programmer",
        "interests" : ["mathematics", "programming"]
    }
```

- **document** is the basic unit of data in MongoDB
- a **Collection** is grouping of those documents
- a **Database** is the container of collections.
- MongoDB Database is the core of Atlas

## document model

- documents are displayed in JSON but stored in BSON(Binary JSON) -> BSON also adds support for datatypes unavailable in JSON
- _ObjectID_ a special datatype to create unique identifiers in MongoDB
- every document requires an \_id field that acts as a primary key, if not provided then ObjectId is automatically generated by MongoDB
- The values in a document can be any data type, including strings, objects, arrays, booleans, nulls, dates, ObjectIds, and more.

```javascript

{
    "key" : value,
    "key" : value,
    "key" : value,
}

// example

{
    "_id" : 1,
    "name" : "AC3 Phone",
    "colors" : ["black", "silver"],
    "price" : 200,
    "available" : true
}


```

## MongoDB Connection String

- allows us to connect to our cluster and work with our data and options for connecting to our MongoDB Database
- has two formats for connection string:
  1. standard format : used to connect to standalone clusters, replica sets, or sharded ckusters
  2. DNS seed list format
     - provides a DNS server list to our connection string
     - Gives more flexibility of deployment
     - ability to change servers in rotation without reconfiguring clients
- The connection list from the Atlas dashboard, uses a _DNS seed list entry_, which has a list of hosts that can be connected with.
  ### Connection String
  - example of connection string : **mongodb+srv://{username}:{password}@cluster0.usqsf.mongodb.net/?retryWrites=true&w=majority**
  - begins with the required prefix _mongodb_ that identifies it is as a mongoDB connection string,
  - the _+srv_ automatically sets the TLS security option to true and tells mongoDB to use the DNS seed list
  - then the _username_ and _password_ of the database in Atlas dashboard
  - _@cluster0.usqsf.mongodb.net_ - host and the optional port number to our database(if not specified then default port number is 27017)
  - any extra optional query parameters for additional information : here _retryWrites=true_ means to retry the write ops when failed

## MongoDB Shell

- a NodeJS REPL environment that gives access to JS variables, loops, control structures, etc.

## MongoDB Compass

- a GUI, that allows us to query and analyse our data, and compose aggregation pipelines

## Connection Errors

- mainly two types of errors:
  1. Network Access Errors - If IP Address isn't allowed by the MongoDB
  2. User Authentication Errors - If anything goes wrong in the connection string

## Inserting documents in MongoDB

- two methods used to insert documents in MongoDB:
  1. **insertOne()**:
     - used to insert one document at a time
     - Syntax { db.collectionName.insertOne() }
     - if the specified collection name doesn't exist then, mongoDB automatically creates that collection and inserts the data to it.
     - the document parameters are inserted inside the parenthesis of insertOne method.
     ```javascript
     db.grades.insertOne({
       student_id: 654321,
       products: [
         {
           type: "exam",
           score: 90,
         },
         {
           type: "homework",
           score: 59,
         },
         {
           type: "quiz",
           score: 75,
         },
         {
           type: "homework",
           score: 88,
         },
       ],
       class_id: 550,
     });
     ```
  2. **insertMany()**:
     - inserts many document at a time
     - expects an array of documents
     - Syntax { db.collectionName.insertMany(
       (document_1), (document_2), (document_3), etc.
       ) }
     ```javascript
     db.grades.insertMany([
       {
         student_id: 546789,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 551,
       },
       {
         student_id: 777777,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 458,
       },
       {
         student_id: 645372,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 271,
       },
     ]);
     ```

## Finding documents

- **find()**:
  - syntax
  ```javascript
  db.collectionName.find();
  ```
  - use **it** shell directive for more results
- to find a specific document:

  - for single document finding
  - **$eq** operator

  ```javascript
   {field : {$eq : <value>}}
   // or this
   {field : <value>}

   // in action
   db.collectionName.find({field : {$eq : <value>}})
   db.collectionName.find({field : <value>})
  ```

- **$in**:
  - The **$in** operator allows us to select all the documents that have a field value equal to any of the values specified in the array.
  - multiple documents finding
  ```javascript
  // db.collectionName.find({field : {$in : [value1, value2, etc...]}})
  db.zips.find({ city: { $in: ["Phoenix", "Chicago"] } });
  ```

## Comparison Operators in MongoDB

- **< -> $lt** : returns documents where the field contains a value less than the specified value.
- **> -> $gt** : returns documents where the field contains a value greater than the specified value.
- **<=-> $lte** : returns documents less than or equal to a given number.
- **>=-> $gte** : returns documents greater than or equal to a given number.
- usage : { field : { operator : value } }

- subfields of any field in a document can be accessed by chaining with dot notation (eg. "items.price")

## Querying arrays in MongoDB

- same using the implicit **$eq** operator for it
- db.collectionName.find{"arrayName" : "value"} -> returns the documents with the single matching value or an array containing this value
- but this returns the array as well as the single matching value

* to avoid this using the **$elemMatch** operator with **$eq** operator

- db.collectionName.find{
  "arrayName" : {
  $elemMatch : { $eq : value }
  }
  } this returns the documents with the array containing the specified value

- multiple queries can be given by seperating them by commas
- db.collectionName.find({
  arrayName : {
  $elemMatch : {query1, query2, query3 ,etc}
  }
  })
  this returns the documents with the array satisfing all the queries specified

## Logical Operators in MongoDB

- $and : performs logical _and_ operation on the expressions in the array
- db.colleactionName.find({
  $and : [{exp1}, {exp2}, ...]
  })
  or
  db.collectionName.find({{exp1}, {exp2}, ...})
- $or : performs logical _or_ operation on the expressions in the array
- db.collectionName.find({
  $or : [{exp1}, {exp2}, ...]
  })

### using $and operator with $or operator

- we can use $and operator with $or operator in MongoDB to filter documents better

```javascript
db.collectionName.find({
    $and : [
        {
            $or : [{exp1}, {exp2}, ...]
        },
        {
            $or : [{exp1}, {exp2}, ...]
        },
        ...
    ]
})
```

- we can't use the implicit $and operator syntax here bcz in a single JSON object, no duplicate keys is allowed, so if two $or operators are used then the former $or oprator will be replaced or overwritten by the latter $or operator

```javascript
db.collectionName.find({
        $or : [{exp1}, {exp2}, ...],
        $or : [{exp1}, {exp2}, ...]
})
```

- when including the same operator more than once in your query, you need to use the explicit $and operator

## Replacing a document in MongoDB

1. Using the **replaceOne()** method :

- used to replace single document
- accepts three arguments (filter, replacement, options)

- syntax : db.collectionName.replaceOne()

  - filter : used to filter out the document to be replaced especially by \_id fields
  - replacement : contains the data to be replaced

- example :

```javascript
// takes first arg as the _id of the target document
db.books.replaceOne(
  {
    _id: ObjectId("6282afeb441a74a98dbbec4e"),
  },
  {
    title: "Data Science Fundamentals for Python and MongoDB",
    isbn: "1484235967",
    publishedDate: new Date("2018-5-10"),
    thumbnailUrl:
      "https://m.media-amazon.com/images/I/71opmUBc2wL._AC_UY218_.jpg",
    authors: ["David Paper"],
    categories: ["Data Science"],
  }
);
```

## Updating a document in MongoDB

- Using the **updateOne()** method :
  - updates the single document
  - takes three arguments -> filter(contains the selectioin criteria of the target document), update(data to be updated), and options object
  - we use operators like **$set** {adds new fields and values to a document ; Replaces the value of a field with a specified value} and **$push** {appends a value to an array : if absent, $push adds the array field with the value as its element} ; **$each** modifier to add multiple elements to the array
  - this is possible that the mathcing document may not exist, here **upsert** comes into the picture. (keyword used in options object)
  - **upsert** : Insert a document with the provided information if matching documents don't exist.

```javascript
// $set keyword
db.podcasts.updateOne(
  {
    _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8"),
  },

  {
    $set: {
      subscribers: 98562,
    },
  }
);

// upsert with $set
db.podcasts.updateOne(
  { title: "The Developer Hub" },
  { $set: { topics: ["databases", "MongoDB"] } },
  { upsert: true }
);

// $push keyword
db.podcasts.updateOne(
  { _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8") },
  { $push: { hosts: "Nic Raboy" } }
)
```
- Using the **findAndModify()** method :
  - returns the document that has been recently updated
  - alternative approach of this can be updateOne() + findOne(), but that's expensive operation as it does two rounds of trip to the server to get the data and there is a chance that the document might be updated before we get the _id of that document
  - so, its the best approach for it
  - takes three arguments : 
    1. query - for filtering the document
    2. update - data to be updated
    3. new - boolean value : whether to return the modified document after the update operation or without the update operation
```javascript
db.podcasts.findAndModify({
  query: { _id: ObjectId("6261a92dfee1ff300dc80bf1") },
  update: { $inc: { subscribers: 1 } },
  new: true,
})
// new is set to true means that it'll return the updated document

```

- Using the updateMany() method : 
  - takes three args:
    1. filter document
    2. update document
    3. option object
  
  - Not an all-or-nothing operation
  - will not rollback updates
  - Updates will be visible as soon as they're performed
  - not appropriate for some use cases
```javascript
db.books.updateMany(
  { publishedDate: { $lt: new Date("2019-01-01") } }, // filter is the data which are less than or before the given date
  { $set: { status: "LEGACY" } }
)
```

## Deleting the document in MongoDB

- Using the **deleteOne()** and **deleteMany()** methods that takes the query parameter to filter out the documents to be deleted
```javascript

db.podcasts.deleteOne({ _id: Objectid("6282c9862acb966e76bbf20a") })

db.podcasts.deleteMany({category: “crime”})

```