# MongoDB

## Introduction

- a general purpose document database, structure data into documents similar to JSON objects
- not using the relational database schemas of tables, columns or rows
- offers a developer-friendly way to access the data
- corresponds objects in code
- document model is easier to plan how application data will correspond to data in the databases
- model data of any shape or structure
- use one format for every language

```javascript
    // example of a document
    {
        "id" : 1,
        "name" : {
            "first" : "Ada",
            "last" : "Lovelace"
        },
        "title" : "The First Programmer",
        "interests" : ["mathematics", "programming"]
    }
```

- **document** is the basic unit of data in MongoDB
- a **Collection** is grouping of those documents
- a **Database** is the container of collections.
- MongoDB Database is the core of Atlas

## document model

- documents are displayed in JSON but stored in BSON(Binary JSON) -> BSON also adds support for datatypes unavailable in JSON
- _ObjectID_ a special datatype to create unique identifiers in MongoDB
- every document requires an \_id field that acts as a primary key, if not provided then ObjectId is automatically generated by MongoDB
- The values in a document can be any data type, including strings, objects, arrays, booleans, nulls, dates, ObjectIds, and more.

```javascript

{
    "key" : value,
    "key" : value,
    "key" : value,
}

// example

{
    "_id" : 1,
    "name" : "AC3 Phone",
    "colors" : ["black", "silver"],
    "price" : 200,
    "available" : true
}


```

## MongoDB Connection String

- allows us to connect to our cluster and work with our data and options for connecting to our MongoDB Database
- has two formats for connection string:
  1. standard format : used to connect to standalone clusters, replica sets, or sharded ckusters
  2. DNS seed list format
     - provides a DNS server list to our connection string
     - Gives more flexibility of deployment
     - ability to change servers in rotation without reconfiguring clients
- The connection list from the Atlas dashboard, uses a _DNS seed list entry_, which has a list of hosts that can be connected with.
  ### Connection String
  - example of connection string : **mongodb+srv://{username}:{password}@cluster0.usqsf.mongodb.net/?retryWrites=true&w=majority**
  - begins with the required prefix _mongodb_ that identifies it is as a mongoDB connection string,
  - the _+srv_ automatically sets the TLS security option to true and tells mongoDB to use the DNS seed list
  - then the _username_ and _password_ of the database in Atlas dashboard
  - _@cluster0.usqsf.mongodb.net_ - host and the optional port number to our database(if not specified then default port number is 27017)
  - any extra optional query parameters for additional information : here _retryWrites=true_ means to retry the write ops when failed

## MongoDB Shell

- a NodeJS REPL environment that gives access to JS variables, loops, control structures, etc.

## MongoDB Compass

- a GUI, that allows us to query and analyse our data, and compose aggregation pipelines

## Connection Errors

- mainly two types of errors:
  1. Network Access Errors - If IP Address isn't allowed by the MongoDB
  2. User Authentication Errors - If anything goes wrong in the connection string

## Inserting documents in MongoDB

- two methods used to insert documents in MongoDB:
  1. **insertOne()**:
     - used to insert one document at a time
     - Syntax { db.collectionName.insertOne() }
     - if the specified collection name doesn't exist then, mongoDB automatically creates that collection and inserts the data to it.
     - the document parameters are inserted inside the parenthesis of insertOne method.
     ```javascript
     db.grades.insertOne({
       student_id: 654321,
       products: [
         {
           type: "exam",
           score: 90,
         },
         {
           type: "homework",
           score: 59,
         },
         {
           type: "quiz",
           score: 75,
         },
         {
           type: "homework",
           score: 88,
         },
       ],
       class_id: 550,
     });
     ```
  2. **insertMany()**:
     - inserts many document at a time
     - expects an array of documents
     - Syntax { db.collectionName.insertMany(
       (document_1), (document_2), (document_3), etc.
       ) }
     ```javascript
     db.grades.insertMany([
       {
         student_id: 546789,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 551,
       },
       {
         student_id: 777777,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 458,
       },
       {
         student_id: 645372,
         products: [
           {
             type: "quiz",
             score: 50,
           },
           {
             type: "homework",
             score: 70,
           },
           {
             type: "quiz",
             score: 60,
           },
           {
             type: "exam",
             score: 80,
           },
         ],
         class_id: 271,
       },
     ]);
     ```

## Finding documents

- **find()**:
  - syntax
  ```javascript
  db.collectionName.find();
  ```
  - use **it** shell directive for more results
- to find a specific document:

  - for single document finding
  - **$eq** operator

  ```javascript
   {field : {$eq : <value>}}
   // or this
   {field : <value>}

   // in action
   db.collectionName.find({field : {$eq : <value>}})
   db.collectionName.find({field : <value>})
  ```

- **$in**:
  - The **$in** operator allows us to select all the documents that have a field value equal to any of the values specified in the array.
  - multiple documents finding
  ```javascript
  // db.collectionName.find({field : {$in : [value1, value2, etc...]}})
  db.zips.find({ city: { $in: ["Phoenix", "Chicago"] } });
  ```

## Comparison Operators in MongoDB

- **< -> $lt** : returns documents where the field contains a value less than the specified value.
- **> -> $gt** : returns documents where the field contains a value greater than the specified value.
- **<=-> $lte** : returns documents less than or equal to a given number.
- **>=-> $gte** : returns documents greater than or equal to a given number.
- usage : { field : { operator : value } }

- subfields of any field in a document can be accessed by chaining with dot notation (eg. "items.price")

## Querying arrays in MongoDB

- same using the implicit **$eq** operator for it
- db.collectionName.find{"arrayName" : "value"} -> returns the documents with the single matching value or an array containing this value
- but this returns the array as well as the single matching value

* to avoid this using the **$elemMatch** operator with **$eq** operator

- db.collectionName.find{
  "arrayName" : {
  $elemMatch : { $eq : value }
  }
  } this returns the documents with the array containing the specified value

- multiple queries can be given by seperating them by commas
- db.collectionName.find({
  arrayName : {
  $elemMatch : {query1, query2, query3 ,etc}
  }
  })
  this returns the documents with the array satisfing all the queries specified

## Logical Operators in MongoDB

- $and : performs logical _and_ operation on the expressions in the array
- db.colleactionName.find({
  $and : [{exp1}, {exp2}, ...]
  })
  or
  db.collectionName.find({{exp1}, {exp2}, ...})
- $or : performs logical _or_ operation on the expressions in the array
- db.collectionName.find({
  $or : [{exp1}, {exp2}, ...]
  })

### using $and operator with $or operator

- we can use $and operator with $or operator in MongoDB to filter documents better

```javascript
db.collectionName.find({
    $and : [
        {
            $or : [{exp1}, {exp2}, ...]
        },
        {
            $or : [{exp1}, {exp2}, ...]
        },
        ...
    ]
})
```

- we can't use the implicit $and operator syntax here bcz in a single JSON object, no duplicate keys is allowed, so if two $or operators are used then the former $or oprator will be replaced or overwritten by the latter $or operator

```javascript
db.collectionName.find({
        $or : [{exp1}, {exp2}, ...],
        $or : [{exp1}, {exp2}, ...]
})
```

- when including the same operator more than once in your query, you need to use the explicit $and operator

## Replacing a document in MongoDB

1. Using the **replaceOne()** method :

- used to replace single document
- accepts three arguments (filter, replacement, options)

- syntax : db.collectionName.replaceOne()

  - filter : used to filter out the document to be replaced especially by \_id fields
  - replacement : contains the data to be replaced

- example :

```javascript
// takes first arg as the _id of the target document
db.books.replaceOne(
  {
    _id: ObjectId("6282afeb441a74a98dbbec4e"),
  },
  {
    title: "Data Science Fundamentals for Python and MongoDB",
    isbn: "1484235967",
    publishedDate: new Date("2018-5-10"),
    thumbnailUrl:
      "https://m.media-amazon.com/images/I/71opmUBc2wL._AC_UY218_.jpg",
    authors: ["David Paper"],
    categories: ["Data Science"],
  }
);
```

## Updating a document in MongoDB

- Using the **updateOne()** method :
  - updates the single document
  - takes three arguments -> filter(contains the selectioin criteria of the target document), update(data to be updated), and options object
  - we use operators like **$set** {adds new fields and values to a document ; Replaces the value of a field with a specified value} and **$push** {appends a value to an array : if absent, $push adds the array field with the value as its element} ; **$each\*\* modifier to add multiple elements to the array
  - this is possible that the mathcing document may not exist, here **upsert** comes into the picture. (keyword used in options object)
  - **upsert** : Insert a document with the provided information if matching documents don't exist.

```javascript
// $set keyword
db.podcasts.updateOne(
  {
    _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8"),
  },

  {
    $set: {
      subscribers: 98562,
    },
  }
);

// upsert with $set
db.podcasts.updateOne(
  { title: "The Developer Hub" },
  { $set: { topics: ["databases", "MongoDB"] } },
  { upsert: true }
);

// $push keyword
db.podcasts.updateOne(
  { _id: ObjectId("5e8f8f8f8f8f8f8f8f8f8f8") },
  { $push: { hosts: "Nic Raboy" } }
);
```

- Using the **findAndModify()** method :
  - returns the document that has been recently updated
  - alternative approach of this can be updateOne() + findOne(), but that's expensive operation as it does two rounds of trip to the server to get the data and there is a chance that the document might be updated before we get the \_id of that document
  - so, its the best approach for it
  - takes three arguments :
    1. query - for filtering the document
    2. update - data to be updated
    3. new - boolean value : whether to return the modified document after the update operation or without the update operation

```javascript
db.podcasts.findAndModify({
  query: { _id: ObjectId("6261a92dfee1ff300dc80bf1") },
  update: { $inc: { subscribers: 1 } },
  new: true,
});
// new is set to true means that it'll return the updated document
```

- Using the updateMany() method :

  - takes three args:

    1. filter document
    2. update document
    3. option object

  - Not an all-or-nothing operation
  - will not rollback updates
  - Updates will be visible as soon as they're performed
  - not appropriate for some use cases

```javascript
db.books.updateMany(
  { publishedDate: { $lt: new Date("2019-01-01") } }, // filter is the data which are less than or before the given date
  { $set: { status: "LEGACY" } }
);
```

## Deleting the document in MongoDB

- Using the **deleteOne()** and **deleteMany()** methods that takes the query parameter to filter out the documents to be deleted

```javascript

db.podcasts.deleteOne({ _id: Objectid("6282c9862acb966e76bbf20a") })

db.podcasts.deleteMany({category: “crime”})

```

## Sorting and Limiting Query Results in MongoDB

- **Cursor** :
  - pointer to the result set of a query
  - find() returns the cursor that points to the document that matches the query
  - _Cursor methods_ are chained to queries, perform actions on the result set
  - using _projections_ to seek the desired field in the document rather than the whole document
- using the cursor methods like:

  1. cursor.sort() :

  - passing a document to ensure the order of sorting
  - 1 for ascending, -1 for descending
  - Alphabetisation in MongoDB means to sort documents in ascending or descending order.
  - in MongoDB, capital letters are sorted first and grouped together then small letters are sorted and grouped together

  2. cursor.limit()

  - limiting the number of results can improve the performance
  - passing a document to ensure the sorting order
  - then, using the limit() method to limit the result set by the integer set at a time
  - also use projections to get the desired fields in the document.

```javascript
// syntax for sort()
  db.collection.find(<query>).sort(<sort>);

// Return data on all music companies, sorted alphabetically from A to Z. Ensure consistent sort order
  db.companies.find({ category_code: "music" }).sort({ name: 1, _id: 1 });

// syntax for limit() method
  db.companies.find(<query>).limit(<number>)

// Return the three music companies with the highest number of employees. Ensure consistent sort order.
db.companies
  .find({ category_code: "music" })
  .sort({ number_of_employees: -1, _id: 1 })
  .limit(3);

```

## Returning selected field from the query

- by default the find() method returns the whole document, whether the user wants the whole or not
- using Projections: selecting the required fields from the document to format the result better
- giving an extra argument as a document and key as the field to be displayed
- value of those field can be 1 or 0 depending on whether the field should be included or excluded from the result
- inclusion and exclusion statements can't be combined in projections, except \_id field

```javascript
// syntax
db.collection.find( <query>, <projection> )

// including a field
db.collection.find( <query>, { <field> : 1 })

// example
db.inspections.find(
  { sector: "Restaurant - 818" },
  { business_name: 1, result: 1 }
)

// excluding a field
db.collection.find(query, { <field> : 0, <field>: 0 })


// example
db.inspections.find(
  { result: { $in: ["Pass", "Warning"] } },
  { date: 0, "address.zip": 0 }
)

```

## Counting Documents in MongoDB

- db.collection.countDocuments() method is used to count the documents from a specified query
- takes two parameters :
  1. query - for selecting the documents
  2. options - for counting behaviour

```javascript

// syntax
db.collection.countDocuments( <query>, <options> )

// Count number of docs in trip collection
db.trips.countDocuments({})

// Count number of trips over 120 minutes by subscribers
db.trips.countDocuments({ tripduration: { $gt: 120 }, usertype: "Subscriber" })

```

## Aggregation and Pipelines

- **Aggregation** : An analysis and summary of data
- **Stage** : An aggregation operation performed on the data ; single operation on the data
- **Aggregation Pipeline** : A series of completed one at a time, in order

- aggregation() takes an array of aggregation stages to form the pipeline

```javascript
// syntax
db.collection.aggregate([
  {$stage_name : {expression}},
  {$stage_name : {expression}},
  {$stage_name : {expression}},
  ...
])

// structure of an aggregation pipeline
db.collection.aggregate([
    {
        $stage1: {
            { expression1 },
            { expression2 }...
        },
        $stage2: {
            { expression1 }...
        }
    }
])
```

- '$' is considered as field path; allows us to refer the value of that field
- commonly used stages are:

  1. $match : filter for data that matches the criteria ; place it as early as possible in the pipelines so it can use indexes

     ```javascript
     {
       $match : {
         "field_name" : "value"
       }
     }

     ```

  2. $group : groups documents based on a group key ; creates a single document for each distinct value ; output is one document for each unique value of the group key

     ```javascript
     {
       $group : {
         _id : "expression",
         "field" : {"accumulator" : "expression"}
       }
     }

     ```

     ```javascript
     // using $match and $group together
     db.zips.aggregate([
       {
         $match: {
           state: "CA",
         },
       },
       {
         $group: {
           _id: "$city",
           totalZips: { $count: {} },
         },
       },
     ]);
     ```

  3. $sort : puts the documents in a specific order ; sorts all the input documents and passes them through pipeline in sorted order ; value : 1 for ascending and -1 for descending order
  4. $limit : limits the number of documents that are passed on to the next aggregation stage

  ```javascript
  // example of $sort and $limit
  db.zips.aggregate([
    {
      $sort: {
        pop: -1,
      },
    },
    {
      $limit: 5,
    },
  ]);
  ```

  5. $set : add or modifies fields in the pipeline ; useful when we want to change existing fields in pipeline or add new ones to be used in upcoming pipeline stages
  6. $count : counts documents in the pipeline ; returns the total document count
  7. $project : determines output shape ; projection similar to find() operations ; should be the last stage to format the output

  ```javascript
  // $project
  {
    $project: {
        state:1,
        zip:1,
        population:"$pop",
        _id:0
    }
  }

  // $set
  {
    $set : {
      place : {
        $concat : ["$city", ",", "$state"]
      },
      pop : 10000
    }
  }

  // $count
  {
    $count :  "total_zips" // field name to be total_zips
  }
  ```

  8. $out :

  - writes documents that are returned by an aggregation pipeline into a collection
  - must be the last stage
  - creates a new collection if it doesn't already exist
  - if collection exists, it replaces the existing collection with new data

  ```javascript
  // syntax
  {
    $out : {
      db : "dbName",
      coll : "collectionName"
    }
  }

  // if db not given then default takes current db
  {
    $out : "collectionName"
  }

  // example
  db.collection.aggregate([
    {
      $match : {},
    },
    {
      $group : {}
    },
    {
      $out : {}
    }
  ])
  ```

## Indexes in MongoDB

- special data structures, store small portion of the data
- ordered and easy to search efficiently
- point to the document directly
- improves query performance

  - speed up queries, reduce disk I/O
  - reduce resources required,
  - support equality matches and range-based operations and return sorted results

  ### without indexes

  - reads all documents(collection scan)
  - sorts result in memory

  ### with indexes

  - only fetches the documents identified by the index based on the query
  - returns result faster

- one default index per collection, which includes \_id field
- every query should use an index
- if we insert or update documents, we need to update the index data structure
- Delete unnecessary or redundant indexes

  ### most common types of indexes

  1. single field : indexes on one field only
      - index for single field ; support queries and sort on a single field
      - using the `createIndex()` method here and passing the fieldName and order of indexing(ascending{1} or descending{-1})
      - `getIndexes()` used to return the created indexes on a collection
      ```javascript
      db.collection.createIndex({fieldName : 1}) // indexing created in ascending order
      ```
      - `explain()` to see the execution plan, specifying the execution stages:
        - **IXSCAN** : indicates the query is using an index and what index is being selected
        - **COLLSACN** : indicates a collection scan is perform, not using any indexes
        - **FETCH** : indicates documents are being read from the collection
        - **SORT** : indicates documents are being sorted in memory

  2. compound field : more than one field in the index

  - multikeys indexes operate on array fields

  ```javascript
  // single field index creation
  db.customers.createIndex({
    birthdate: 1,
  });

  // unique single field creation
  db.customers.createIndex({
    email : 1
  },
  {
    unique : true
  })

  // getIndexes to view the indexex created
  db.customers.getIndexes()

  // checking if an index is used on a query or not
  db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  })

  // checking again the execution plan
  db.customers.explain().find({
    birthdate : {
      $gt : ISODate("1995-08-01")
    }
  }).sort({
    email : 1
  })
  ```
